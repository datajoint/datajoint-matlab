{"config": {"indexing": "full", "lang": ["en"], "min_search_length": 3, "prebuild_index": false, "separator": "[\\s\\-]+"}, "docs": [{"location": "changelog/", "text": "Changelog \u00b6 Observes Semantic Versioning standard and Keep a Changelog convention. 3.5.0 - 2022-03-21 \u00b6 Bugfix: Cascading delete for renamed foreign keys (#379) PR #386 Minor: Add renaming the same attribute multiple times within a single projection PR #386 Minor: Add config for reading values with 32-bit dimensions (datajoint/mym#86) PR #395", "title": "Changelog"}, {"location": "changelog/#changelog", "text": "Observes Semantic Versioning standard and Keep a Changelog convention.", "title": "Changelog"}, {"location": "changelog/#350-2022-03-21", "text": "Bugfix: Cascading delete for renamed foreign keys (#379) PR #386 Minor: Add renaming the same attribute multiple times within a single projection PR #386 Minor: Add config for reading values with 32-bit dimensions (datajoint/mym#86) PR #395", "title": "3.5.0 - 2022-03-21"}, {"location": "tutorials/", "text": "Tutorials \u00b6 Coming soon!", "title": "Tutorials"}, {"location": "tutorials/#tutorials", "text": "Coming soon!", "title": "Tutorials"}, {"location": "concepts/existing-pipelines/", "text": "Existing Pipelines \u00b6 This section describes how to work with database schemas without access to the original code that generated the schema. These situations often arise when the database is created by another user who has not shared the generating code yet or when the database schema is created from a programming language other than Matlab. Creating a virtual class \u00b6 DataJoint MATLAB creates a TableAccessor property in each schema object. The TableAccessor property, a virtual class generator , is available as schema.v , and allows listing and querying of the tables defined on the server without needing to create the MATLAB table definitions locally. For example, creating a scratch experiment schema package and querying an existing my_experiment.Session table on the server can be done as follows: dj . createSchema ( 'experiment' , '/scratch' , 'my_experiment' ) addpath ( '/scratch' ) experiment_schema = experiment . getSchema (); experiment_schema . v . Session () & 'session_id=1234' ; Note You can view the available tables in a schema by using tab completion on the schema.v property. To visualize an unfamiliar schema, see commands for generating diagrams .", "title": "Existing Pipelines"}, {"location": "concepts/existing-pipelines/#existing-pipelines", "text": "This section describes how to work with database schemas without access to the original code that generated the schema. These situations often arise when the database is created by another user who has not shared the generating code yet or when the database schema is created from a programming language other than Matlab.", "title": "Existing Pipelines"}, {"location": "concepts/existing-pipelines/#creating-a-virtual-class", "text": "DataJoint MATLAB creates a TableAccessor property in each schema object. The TableAccessor property, a virtual class generator , is available as schema.v , and allows listing and querying of the tables defined on the server without needing to create the MATLAB table definitions locally. For example, creating a scratch experiment schema package and querying an existing my_experiment.Session table on the server can be done as follows: dj . createSchema ( 'experiment' , '/scratch' , 'my_experiment' ) addpath ( '/scratch' ) experiment_schema = experiment . getSchema (); experiment_schema . v . Session () & 'session_id=1234' ; Note You can view the available tables in a schema by using tab completion on the schema.v property. To visualize an unfamiliar schema, see commands for generating diagrams .", "title": "Creating a virtual class"}, {"location": "getting-started/", "text": "Getting Started \u00b6 Installation \u00b6 First, please install DataJoint via one of the following: Matlab \u2265 R2016b (recommended) Matlab < R2016 GHToolbox From source Utilize MATLAB built-in GUI i.e. Top Ribbon -> Add-Ons -> Get Add-Ons Search and Select DataJoint Select Add from GitHub Utilize MATLAB built-in GUI i.e. Top Ribbon -> Add-Ons -> Get Add-Ons Search and Select DataJoint Select Download from GitHub Save DataJoint.mltbx locally Navigate in MATLAB tree browser to saved toolbox file Right-Click and Select Install Select Install Install GHToolbox using using an appropriate method in https://github.com/datajoint/GHToolbox run: ghtb.install('datajoint/datajoint-matlab') Download DataJoint.mltbx locally Navigate in MATLAB tree browser to saved toolbox file Right-Click and Select Install Select Install After installing, that you have the latest version from Matlab: >> dj . version DataJoint version 3.5.0 Connection \u00b6 At the MATLAB command prompt, assign the environment variables with the database credentials. For example, if you are connection to the server tutorial-db.datajoint.io with username alice and password fake-password , execute the following commands: setenv DJ_USER alice setenv DJ_HOST tutorial - db . datajoint . io setenv DJ_PASS 'fake-password' Note Although you may connect to any MySQL server of your choice, the DataJoint company offers an online tutorial environment at tutorial-db.datajoint.io . Simply sign up for a free DataJoint account . You will be granted privileges to create schemas that are prefixed as {user}_ . You will need to execute these commands at the beginning of each DataJoint work session. To automate this process, you might add these items to the Matlab startup.m script. However, be careful not to share this file or commit it to a public directory (a common mistake), as it contains a your login credentials in plain text. If you are not sure, it is better not to set DJ_PASS , in which case DataJoint will prompt to enter the password when connecting to the database. To change the database password, use the following command >> dj . setPassword ( 'my#cool!new*password' ) And update your credentials in your startup script for the next session. For more information on various settings, access help via help('dj.config') or review it online here . Creating Schemas \u00b6 A schema can be created either automatically using the dj.createSchema script or manually. While dj.createSchema simplifies the process, we'll also highlight the manual approach to demonstrate each step. Manual \u00b6 We can create the database schema using the following command: query ( dj . conn , 'CREATE SCHEMA `{user}_my_schema`' ) Server privileges You must have create privileges for the schema name pattern. It is a common practice to grant all privileges to users for schemas that begin with the username, in addition to some shared schemas. Thus the user alice would be able to perform any work in any schema that begins with alice_ . Next, we can create the MATLAB package. DataJoint organizes schemas as MATLAB packages . If you are not familiar with packages, please review: How to work with MATLAB packages How to manage MATLAB's search paths In your project directory, create the package folder, which must begin with a + sign. For example, for the schema called my_schema , you would create the folder +my_schema . Make sure that your project directory (the parent directory of your package folder) is added to the MATLAB search path. Finally, we'll associate the package with the database schema. This step tells DataJoint that all classes in the package folder +my_schema will work with tables in the database schema {user}_my_schema . Each package corresponds to exactly one schema. In some special cases, multiple packages may all relate to a single database schema, but in most cases there will be a one-to-one relationship between packages and schemas. In the +my_schema folder, create the file getSchema.m with the following contents: function obj = getSchema persistent OBJ if isempty ( OBJ ) OBJ = dj . Schema ( dj . conn , 'experiment' , 'alice_experiment' ); end obj = OBJ ; end This function returns a persistent object of type dj.Schema , establishing the link between the my_schema package in MATLAB and the schema {user}_my_schema on the database server. Automatic \u00b6 Alternatively, we can execute >> dj . createSchema This automated script will walk you through the steps above and will create the schema, the package folder, and the getSchema function in that folder. Defining Tables \u00b6 DataJoint provides the interactive script dj.new for creating a new table. It will prompt to enter the new table's class name in the form package.ClassName . This will create the file +package/ClassName.m . For example, define the table my_schema.Rectangle >> dj . new Enter < package > . < ClassName > : my_schema . Rectangle Choose table tier : L = lookup M = manual I = imported C = computed P = part ( L / M / I / C / P ) > M This will create the file +my_schema.Rectangle.m with the following contents: %{ # my newest table # add primary key here ----- # add additional attributes %} classdef Rectangle < dj . Manual end While dj.new adds a little bit of convenience, we can also create the classes from scratch manually. Each newly created class must inherit from the DataJoint class corresponding to the correct data tier : dj.Lookup , dj.Manual , dj.Imported or dj.Computed . The most important part of the table definition is the comment preceding the classdef . DataJoint will parse this comment to define the table. The class will become usable after you edit this comment. For example: File +my_schema/Rectangle.m %{ shape_id: int --- shape_height: float shape_width: float %} classdef Rectangle < dj . Manual end File +my_schema/Area.m %{ -> my_schema.Rectangle --- shape_area: float %} classdef Area < dj . Computed end The table definition is contained in the first block comment in the class definition file. Note that although it looks like a mere comment, the table definition is parsed by DataJoint. Users do not need to do anything special to have the table created in the database. The table is created upon the first attempt to use the class for manipulating its data (e.g. inserting or fetching entities). Furthermore, DataJoint provides the syncDef method to update the classdef file definition string for the table with the definition in the actual table: syncDef ( my_schema . Area ) % updates the table definition in file +my_schema/Area.m Diagram \u00b6 Display \u00b6 The diagram displays the relationship of the data model in the data pipeline. This can be done for an entire schema, or multiple schema: draw ( dj . ERD ( my_schema . getSchema )) % OR erd my_schema erd my_schema my_other_schema Or for individual or sets of tables: erd my_schema . Rectangle draw ( dj . ERD ( my_schema . Rectangle ) + dj . ERD ( my_schema . Area )) Customize \u00b6 Adding or substracting a number to a diagram object adds nodes downstream or upstream, respectively, in the pipeline. draw ( dj . ERD ( my_schema . Rectangle ) + 1 ) # (1) Plot all the tables directly downstream from my_schema.Rectangle draw ( dj . ERD ( my_schema ) - 1 + 1 ) # (1) Plot all tables directly downstream of those directly upstream of this schema. Add data \u00b6 Let's add data for a rectangle: insert ( my_schema . Rectangle , { 1 , 2 , 4 }) insert ( my_schema . Rectangle , [{ 2 , 2 , 3 },{ 3 , 4 , 2 }]) Run computation \u00b6 Let's start the computations on our entity: Area . populate ( my_schema . Rectangle ) Query \u00b6 Let's inspect the results. Area & 'shape_area >= 8'", "title": "Getting Started"}, {"location": "getting-started/#getting-started", "text": "", "title": "Getting Started"}, {"location": "getting-started/#installation", "text": "First, please install DataJoint via one of the following: Matlab \u2265 R2016b (recommended) Matlab < R2016 GHToolbox From source Utilize MATLAB built-in GUI i.e. Top Ribbon -> Add-Ons -> Get Add-Ons Search and Select DataJoint Select Add from GitHub Utilize MATLAB built-in GUI i.e. Top Ribbon -> Add-Ons -> Get Add-Ons Search and Select DataJoint Select Download from GitHub Save DataJoint.mltbx locally Navigate in MATLAB tree browser to saved toolbox file Right-Click and Select Install Select Install Install GHToolbox using using an appropriate method in https://github.com/datajoint/GHToolbox run: ghtb.install('datajoint/datajoint-matlab') Download DataJoint.mltbx locally Navigate in MATLAB tree browser to saved toolbox file Right-Click and Select Install Select Install After installing, that you have the latest version from Matlab: >> dj . version DataJoint version 3.5.0", "title": "Installation"}, {"location": "getting-started/#connection", "text": "At the MATLAB command prompt, assign the environment variables with the database credentials. For example, if you are connection to the server tutorial-db.datajoint.io with username alice and password fake-password , execute the following commands: setenv DJ_USER alice setenv DJ_HOST tutorial - db . datajoint . io setenv DJ_PASS 'fake-password' Note Although you may connect to any MySQL server of your choice, the DataJoint company offers an online tutorial environment at tutorial-db.datajoint.io . Simply sign up for a free DataJoint account . You will be granted privileges to create schemas that are prefixed as {user}_ . You will need to execute these commands at the beginning of each DataJoint work session. To automate this process, you might add these items to the Matlab startup.m script. However, be careful not to share this file or commit it to a public directory (a common mistake), as it contains a your login credentials in plain text. If you are not sure, it is better not to set DJ_PASS , in which case DataJoint will prompt to enter the password when connecting to the database. To change the database password, use the following command >> dj . setPassword ( 'my#cool!new*password' ) And update your credentials in your startup script for the next session. For more information on various settings, access help via help('dj.config') or review it online here .", "title": "Connection"}, {"location": "getting-started/#creating-schemas", "text": "A schema can be created either automatically using the dj.createSchema script or manually. While dj.createSchema simplifies the process, we'll also highlight the manual approach to demonstrate each step.", "title": "Creating Schemas"}, {"location": "getting-started/#manual", "text": "We can create the database schema using the following command: query ( dj . conn , 'CREATE SCHEMA `{user}_my_schema`' ) Server privileges You must have create privileges for the schema name pattern. It is a common practice to grant all privileges to users for schemas that begin with the username, in addition to some shared schemas. Thus the user alice would be able to perform any work in any schema that begins with alice_ . Next, we can create the MATLAB package. DataJoint organizes schemas as MATLAB packages . If you are not familiar with packages, please review: How to work with MATLAB packages How to manage MATLAB's search paths In your project directory, create the package folder, which must begin with a + sign. For example, for the schema called my_schema , you would create the folder +my_schema . Make sure that your project directory (the parent directory of your package folder) is added to the MATLAB search path. Finally, we'll associate the package with the database schema. This step tells DataJoint that all classes in the package folder +my_schema will work with tables in the database schema {user}_my_schema . Each package corresponds to exactly one schema. In some special cases, multiple packages may all relate to a single database schema, but in most cases there will be a one-to-one relationship between packages and schemas. In the +my_schema folder, create the file getSchema.m with the following contents: function obj = getSchema persistent OBJ if isempty ( OBJ ) OBJ = dj . Schema ( dj . conn , 'experiment' , 'alice_experiment' ); end obj = OBJ ; end This function returns a persistent object of type dj.Schema , establishing the link between the my_schema package in MATLAB and the schema {user}_my_schema on the database server.", "title": "Manual"}, {"location": "getting-started/#automatic", "text": "Alternatively, we can execute >> dj . createSchema This automated script will walk you through the steps above and will create the schema, the package folder, and the getSchema function in that folder.", "title": "Automatic"}, {"location": "getting-started/#defining-tables", "text": "DataJoint provides the interactive script dj.new for creating a new table. It will prompt to enter the new table's class name in the form package.ClassName . This will create the file +package/ClassName.m . For example, define the table my_schema.Rectangle >> dj . new Enter < package > . < ClassName > : my_schema . Rectangle Choose table tier : L = lookup M = manual I = imported C = computed P = part ( L / M / I / C / P ) > M This will create the file +my_schema.Rectangle.m with the following contents: %{ # my newest table # add primary key here ----- # add additional attributes %} classdef Rectangle < dj . Manual end While dj.new adds a little bit of convenience, we can also create the classes from scratch manually. Each newly created class must inherit from the DataJoint class corresponding to the correct data tier : dj.Lookup , dj.Manual , dj.Imported or dj.Computed . The most important part of the table definition is the comment preceding the classdef . DataJoint will parse this comment to define the table. The class will become usable after you edit this comment. For example: File +my_schema/Rectangle.m %{ shape_id: int --- shape_height: float shape_width: float %} classdef Rectangle < dj . Manual end File +my_schema/Area.m %{ -> my_schema.Rectangle --- shape_area: float %} classdef Area < dj . Computed end The table definition is contained in the first block comment in the class definition file. Note that although it looks like a mere comment, the table definition is parsed by DataJoint. Users do not need to do anything special to have the table created in the database. The table is created upon the first attempt to use the class for manipulating its data (e.g. inserting or fetching entities). Furthermore, DataJoint provides the syncDef method to update the classdef file definition string for the table with the definition in the actual table: syncDef ( my_schema . Area ) % updates the table definition in file +my_schema/Area.m", "title": "Defining Tables"}, {"location": "getting-started/#diagram", "text": "", "title": "Diagram"}, {"location": "getting-started/#display", "text": "The diagram displays the relationship of the data model in the data pipeline. This can be done for an entire schema, or multiple schema: draw ( dj . ERD ( my_schema . getSchema )) % OR erd my_schema erd my_schema my_other_schema Or for individual or sets of tables: erd my_schema . Rectangle draw ( dj . ERD ( my_schema . Rectangle ) + dj . ERD ( my_schema . Area ))", "title": "Display"}, {"location": "getting-started/#customize", "text": "Adding or substracting a number to a diagram object adds nodes downstream or upstream, respectively, in the pipeline. draw ( dj . ERD ( my_schema . Rectangle ) + 1 ) # (1) Plot all the tables directly downstream from my_schema.Rectangle draw ( dj . ERD ( my_schema ) - 1 + 1 ) # (1) Plot all tables directly downstream of those directly upstream of this schema.", "title": "Customize"}, {"location": "getting-started/#add-data", "text": "Let's add data for a rectangle: insert ( my_schema . Rectangle , { 1 , 2 , 4 }) insert ( my_schema . Rectangle , [{ 2 , 2 , 3 },{ 3 , 4 , 2 }])", "title": "Add data"}, {"location": "getting-started/#run-computation", "text": "Let's start the computations on our entity: Area . populate ( my_schema . Rectangle )", "title": "Run computation"}, {"location": "getting-started/#query", "text": "Let's inspect the results. Area & 'shape_area >= 8'", "title": "Query"}, {"location": "query-lang/common-commands/", "text": "Common Commands \u00b6 Make \u00b6 See the article on make methods Fetch \u00b6 DataJoint for MATLAB provides three distinct fetch methods: fetch , fetch1 , and fetchn . The three methods differ by the type and number of their returned variables. query.fetch returns the result in the form of an n \u2a09 1 struct array where n is the number of records matching the query expression. query.fetch1 and query.fetchn split the result into separate output arguments, one for each attribute of the query. The types of the variables returned by fetch1 and fetchn depend on the datatypes of the attributes. query.fetchn will enclose any attributes of char and blob types in cell arrays whereas query.fetch1 will unpack them. MATLAB has two alternative forms of invoking a method on an object: using the dot notation or passing the object as the first argument. The following two notations produce an equivalent result: result = query . fetch ( query , 'attr1' ) result = fetch ( query , 'attr1' ) However, the dot syntax only works when the query object is already assigned to a variable. The second syntax is more commonly used to avoid extra variables. For example, the two methods below are equivalent although the second method creates an extra variable. result = fetch ( my_schema . Rectangle , '*' ); query = my_schema . Rectangle ; result = query . fetch () The primary key \u00b6 Without any arguments, the fetch method retrieves the primary key values of the table in the form of a single column struct . The attribute names become the fieldnames of the struct . keys = query . fetch ; keys = fetch ( my_schema . Rectangle & my_schema . Area ); Note that MATLAB allows calling functions without the parentheses () . An entire query \u00b6 With a single-quoted asterisk ( '*' ) as the input argument, the fetch command retrieves the entire result as a struct array. data = query . fetch ( '*' ); data = fetch ( my_schema . Rectangle & my_schema . Area , '*' ); For very large tables... In some cases, the amount of data returned by fetch can be quite large. When query is a table object rather than a query expression, query.sizeOnDisk() reports the estimated size of the entire table. It can be used to assess whether running query.fetch('*') would be wise. Please note that it is only currently possible to query the size of entire tables stored directly in the database . Separate variables \u00b6 The fetch1 and fetchn methods are used to retrieve each attribute into a separate variable. DataJoint needs two different methods to tell MATLAB whether the result should be in array or scalar form; for numerical fields it does not matter (because scalars are still matrices in MATLAB) but non-uniform collections of values must be enclosed in cell arrays. query.fetch1 is used when query contains exactly one entity, otherwise fetch1 will raise an error. query.fetchn returns an arbitrary number of elements with character arrays and blobs returned in the form of cell arrays, even when query happens to contain a single entity. [ shape_id , height ] = query . fetch1 ( 'shape_id' , 'shape_height' ); % (1) [ shape_ids , heights ] = query . fetchn ( 'shape_id' , 'shape_height' ); % (2) When the table has exactly one entity. When the table has any number of entities: The primary key and individual values \u00b6 It is often convenient to know the primary key values corresponding to attribute values retrieved by fetchn . This can be done by adding a special input argument indicating the request and another output argument to receive the key values: [ shape_ids , heights , keys ] = query . fetchn ( 'shape_id' , 'shape_height' , 'KEY' ); The resulting value of keys will be a column array of type struct . This mechanism is only implemented for fetchn . Rename and calculate \u00b6 In DataJoint for MATLAB, all fetch methods have all the same capability as the proj operator . For example, renaming an attribute can be accomplished using the syntax below. [ shape_ids , perimeter ] = query . fetchn ( 'shape_id' , ... '2*(shape_height+shape_width) -> perimeter' ); See proj for an in-depth description of projection. Sorting results \u00b6 To sort the result, add the additional ORDER BY argument in fetch and fetchn methods as the last argument. The following command retrieves the field shape_id from rectangles with height greater than 2, sorted by width. notes = fetchn ( my_schema . Rectangle & 'shape_height>2\"' , 'shape_id' ... 'ORDER BY shape_width' ); The ORDER BY argument is passed directly to SQL and follows the same syntax as the ORDER BY clause Similarly, the LIMIT and OFFSET clauses can be used to limit the result to a subset of entities. For example, to return the five rectangles with largest area, one could do the following: s = fetch ( my_schema . Area , '*' , 'ORDER BY shape_area DESC LIMIT 5' ) The limit clause is passed directly to SQL and follows the same rules", "title": "Common Commands"}, {"location": "query-lang/common-commands/#common-commands", "text": "", "title": "Common Commands"}, {"location": "query-lang/common-commands/#make", "text": "See the article on make methods", "title": "Make"}, {"location": "query-lang/common-commands/#fetch", "text": "DataJoint for MATLAB provides three distinct fetch methods: fetch , fetch1 , and fetchn . The three methods differ by the type and number of their returned variables. query.fetch returns the result in the form of an n \u2a09 1 struct array where n is the number of records matching the query expression. query.fetch1 and query.fetchn split the result into separate output arguments, one for each attribute of the query. The types of the variables returned by fetch1 and fetchn depend on the datatypes of the attributes. query.fetchn will enclose any attributes of char and blob types in cell arrays whereas query.fetch1 will unpack them. MATLAB has two alternative forms of invoking a method on an object: using the dot notation or passing the object as the first argument. The following two notations produce an equivalent result: result = query . fetch ( query , 'attr1' ) result = fetch ( query , 'attr1' ) However, the dot syntax only works when the query object is already assigned to a variable. The second syntax is more commonly used to avoid extra variables. For example, the two methods below are equivalent although the second method creates an extra variable. result = fetch ( my_schema . Rectangle , '*' ); query = my_schema . Rectangle ; result = query . fetch ()", "title": "Fetch"}, {"location": "query-lang/common-commands/#the-primary-key", "text": "Without any arguments, the fetch method retrieves the primary key values of the table in the form of a single column struct . The attribute names become the fieldnames of the struct . keys = query . fetch ; keys = fetch ( my_schema . Rectangle & my_schema . Area ); Note that MATLAB allows calling functions without the parentheses () .", "title": "The primary key"}, {"location": "query-lang/common-commands/#an-entire-query", "text": "With a single-quoted asterisk ( '*' ) as the input argument, the fetch command retrieves the entire result as a struct array. data = query . fetch ( '*' ); data = fetch ( my_schema . Rectangle & my_schema . Area , '*' ); For very large tables... In some cases, the amount of data returned by fetch can be quite large. When query is a table object rather than a query expression, query.sizeOnDisk() reports the estimated size of the entire table. It can be used to assess whether running query.fetch('*') would be wise. Please note that it is only currently possible to query the size of entire tables stored directly in the database .", "title": "An entire query"}, {"location": "query-lang/common-commands/#separate-variables", "text": "The fetch1 and fetchn methods are used to retrieve each attribute into a separate variable. DataJoint needs two different methods to tell MATLAB whether the result should be in array or scalar form; for numerical fields it does not matter (because scalars are still matrices in MATLAB) but non-uniform collections of values must be enclosed in cell arrays. query.fetch1 is used when query contains exactly one entity, otherwise fetch1 will raise an error. query.fetchn returns an arbitrary number of elements with character arrays and blobs returned in the form of cell arrays, even when query happens to contain a single entity. [ shape_id , height ] = query . fetch1 ( 'shape_id' , 'shape_height' ); % (1) [ shape_ids , heights ] = query . fetchn ( 'shape_id' , 'shape_height' ); % (2) When the table has exactly one entity. When the table has any number of entities:", "title": "Separate variables"}, {"location": "query-lang/common-commands/#the-primary-key-and-individual-values", "text": "It is often convenient to know the primary key values corresponding to attribute values retrieved by fetchn . This can be done by adding a special input argument indicating the request and another output argument to receive the key values: [ shape_ids , heights , keys ] = query . fetchn ( 'shape_id' , 'shape_height' , 'KEY' ); The resulting value of keys will be a column array of type struct . This mechanism is only implemented for fetchn .", "title": "The primary key and individual values"}, {"location": "query-lang/common-commands/#rename-and-calculate", "text": "In DataJoint for MATLAB, all fetch methods have all the same capability as the proj operator . For example, renaming an attribute can be accomplished using the syntax below. [ shape_ids , perimeter ] = query . fetchn ( 'shape_id' , ... '2*(shape_height+shape_width) -> perimeter' ); See proj for an in-depth description of projection.", "title": "Rename and calculate"}, {"location": "query-lang/common-commands/#sorting-results", "text": "To sort the result, add the additional ORDER BY argument in fetch and fetchn methods as the last argument. The following command retrieves the field shape_id from rectangles with height greater than 2, sorted by width. notes = fetchn ( my_schema . Rectangle & 'shape_height>2\"' , 'shape_id' ... 'ORDER BY shape_width' ); The ORDER BY argument is passed directly to SQL and follows the same syntax as the ORDER BY clause Similarly, the LIMIT and OFFSET clauses can be used to limit the result to a subset of entities. For example, to return the five rectangles with largest area, one could do the following: s = fetch ( my_schema . Area , '*' , 'ORDER BY shape_area DESC LIMIT 5' ) The limit clause is passed directly to SQL and follows the same rules", "title": "Sorting results"}, {"location": "query-lang/iteration/", "text": "Iteration \u00b6 The DataJoint model primarily handles data as sets, in the form of tables. However, it can sometimes be useful to access or to perform actions such as visualization upon individual entities sequentially. In DataJoint this is accomplished through iteration. In the simple example below, iteration is used to display the names and values of the primary key attributes of each entity in the simple table or table expression tab . for key = tab . fetch () ' disp ( key ) end Note that the results returned by fetch must be transposed. MATLAB iterates across columns, so the single column struct returned by fetch must be transposed into a single row.", "title": "Iteration"}, {"location": "query-lang/iteration/#iteration", "text": "The DataJoint model primarily handles data as sets, in the form of tables. However, it can sometimes be useful to access or to perform actions such as visualization upon individual entities sequentially. In DataJoint this is accomplished through iteration. In the simple example below, iteration is used to display the names and values of the primary key attributes of each entity in the simple table or table expression tab . for key = tab . fetch () ' disp ( key ) end Note that the results returned by fetch must be transposed. MATLAB iterates across columns, so the single column struct returned by fetch must be transposed into a single row.", "title": "Iteration"}, {"location": "query-lang/operators/", "text": "Operators \u00b6 The examples below will use the table definitions in table tiers . Restriction \u00b6 & and - operators permit restriction. By a mapping \u00b6 For a Session table , that has the attribute session_date , we can restrict to sessions from January 1st, 2022: Session & struct ( 'session_date' , '2018-01-01' ) If there were any typos (e.g., using sess_date instead of session_date ), our query will return all of the entities of Session . By a string \u00b6 Conditions may include arithmetic operations, functions, range tests, etc. Restriction of table A by a string containing an attribute not found in table A produces an error. Session & 'user = \"Alice\"' % (1) Session & 'session_date >= \"2022-01-01\"' % (2) All the sessions performed by Alice All of the sessions on or after January 1st, 2022 By a collection \u00b6 When cond is a collection of conditions, the conditions are applied by logical disjunction (logical OR). Restricting a table by a collection will return all entities that meet any of the conditions in the collection. For example, if we restrict the Session table by a collection containing two conditions, one for user and one for date, the query will return any sessions with a matching user or date. cond_cell = { 'user = \"Alice\"' , 'session_date = \"2022-01-01\"' } % (1) cond_struct = struct ( 'user' , 'Alice' , 'session_date' , '2022-01-01' ) % (2) cond_struct ( 2 ) = struct ( 'user' , 'Jerry' , 'session_date' , '2022-01-01' ) Session () & cond_struct % (3) A cell array A structure array This command will show all the sessions that either Alice or Jerry conducted on the given day. By a query \u00b6 Restriction by a query object is a generalization of restriction by a table. The example below creates a query object corresponding to all the users named Alice. The Session table is then restricted by the query object, returning all the sessions performed by Alice. The Experiment table is then restricted by the query object, returning all the experiments that are part of sessions performed by Alice. query = Session & 'user = \"Alice\"' Experiment & query Proj \u00b6 Renaming an attribute in python can be done via keyword arguments: table ( 'old_attr->new_attr' ) This can be done in the context of a table definition: %{ # Experiment Session -> experiment.Animal session : smallint # session number for the animal --- session_date : date # YYYY-MM-DD session_start_time : float # seconds relative to session_datetime session_end_time : float # seconds relative to session_datetime -> User.proj(experimenter='username') -> User.proj(supervisor='username') %} classdef Session < dj . Manual end Or as part of a query Session * Session . proj ( 'session->other' ) Projection can also be used to to compute new attributes from existing ones. Session . proj ( 'session_end_time-session_start_time -> duration' ) & 'duration > 10' Aggr \u00b6 For more complicated calculations, we can use aggregation. Subject . aggr ( Session , 'count(*)->n' ) % (1) Subject . aggr ( Session , 'avg(session_start_time)->average_start' ) % (2) Number of sessions per subject. Average session_start_time for each subject Universal set \u00b6 Warning dj.U is not yet implemented in MATLAB. The feature will be added in an upcoming release. You can track progress with this GitHub issue . Universal sets offer the complete list of combinations of attributes. dj . U ( 'laser_wavelength' , 'laser_power' ) & Scan % (1) dj . U ( 'laser_wavelength' , 'laser_power' ). aggr ( Scan , 'count(*)->n' ) % (2) dj . U (). aggr ( Session , 'max(session)->n' ) % (3) All combinations of wavelength and power. Total number of scans for each combination. Largest session number. dj.U() , as shown in the last example above, is often useful for integer IDs. For an example of this process, see the source code for Element Array Electrophysiology's insert_new_params .", "title": "Operators"}, {"location": "query-lang/operators/#operators", "text": "The examples below will use the table definitions in table tiers .", "title": "Operators"}, {"location": "query-lang/operators/#restriction", "text": "& and - operators permit restriction.", "title": "Restriction"}, {"location": "query-lang/operators/#by-a-mapping", "text": "For a Session table , that has the attribute session_date , we can restrict to sessions from January 1st, 2022: Session & struct ( 'session_date' , '2018-01-01' ) If there were any typos (e.g., using sess_date instead of session_date ), our query will return all of the entities of Session .", "title": "By a mapping"}, {"location": "query-lang/operators/#by-a-string", "text": "Conditions may include arithmetic operations, functions, range tests, etc. Restriction of table A by a string containing an attribute not found in table A produces an error. Session & 'user = \"Alice\"' % (1) Session & 'session_date >= \"2022-01-01\"' % (2) All the sessions performed by Alice All of the sessions on or after January 1st, 2022", "title": "By a string"}, {"location": "query-lang/operators/#by-a-collection", "text": "When cond is a collection of conditions, the conditions are applied by logical disjunction (logical OR). Restricting a table by a collection will return all entities that meet any of the conditions in the collection. For example, if we restrict the Session table by a collection containing two conditions, one for user and one for date, the query will return any sessions with a matching user or date. cond_cell = { 'user = \"Alice\"' , 'session_date = \"2022-01-01\"' } % (1) cond_struct = struct ( 'user' , 'Alice' , 'session_date' , '2022-01-01' ) % (2) cond_struct ( 2 ) = struct ( 'user' , 'Jerry' , 'session_date' , '2022-01-01' ) Session () & cond_struct % (3) A cell array A structure array This command will show all the sessions that either Alice or Jerry conducted on the given day.", "title": "By a collection"}, {"location": "query-lang/operators/#by-a-query", "text": "Restriction by a query object is a generalization of restriction by a table. The example below creates a query object corresponding to all the users named Alice. The Session table is then restricted by the query object, returning all the sessions performed by Alice. The Experiment table is then restricted by the query object, returning all the experiments that are part of sessions performed by Alice. query = Session & 'user = \"Alice\"' Experiment & query", "title": "By a query"}, {"location": "query-lang/operators/#proj", "text": "Renaming an attribute in python can be done via keyword arguments: table ( 'old_attr->new_attr' ) This can be done in the context of a table definition: %{ # Experiment Session -> experiment.Animal session : smallint # session number for the animal --- session_date : date # YYYY-MM-DD session_start_time : float # seconds relative to session_datetime session_end_time : float # seconds relative to session_datetime -> User.proj(experimenter='username') -> User.proj(supervisor='username') %} classdef Session < dj . Manual end Or as part of a query Session * Session . proj ( 'session->other' ) Projection can also be used to to compute new attributes from existing ones. Session . proj ( 'session_end_time-session_start_time -> duration' ) & 'duration > 10'", "title": "Proj"}, {"location": "query-lang/operators/#aggr", "text": "For more complicated calculations, we can use aggregation. Subject . aggr ( Session , 'count(*)->n' ) % (1) Subject . aggr ( Session , 'avg(session_start_time)->average_start' ) % (2) Number of sessions per subject. Average session_start_time for each subject", "title": "Aggr"}, {"location": "query-lang/operators/#universal-set", "text": "Warning dj.U is not yet implemented in MATLAB. The feature will be added in an upcoming release. You can track progress with this GitHub issue . Universal sets offer the complete list of combinations of attributes. dj . U ( 'laser_wavelength' , 'laser_power' ) & Scan % (1) dj . U ( 'laser_wavelength' , 'laser_power' ). aggr ( Scan , 'count(*)->n' ) % (2) dj . U (). aggr ( Session , 'max(session)->n' ) % (3) All combinations of wavelength and power. Total number of scans for each combination. Largest session number. dj.U() , as shown in the last example above, is often useful for integer IDs. For an example of this process, see the source code for Element Array Electrophysiology's insert_new_params .", "title": "Universal set"}, {"location": "reproduce/make-method/", "text": "Make Method \u00b6 Consider the following table definition from the article on table tiers : %{ Filtered image -> test . Image --- filtered_image : longblob %} classdef FilteredImage < dj . Computed methods ( Access = protected ) function makeTuples ( self, key ) img = fetch1 ( test . Image & key , 'image' ); key . filtered_image = my_filter ( img ); self . insert ( key ) end end end The FilteredImage table can be populated as populate ( test . FilteredImage ) Note that it is not necessary to specify which data needs to be computed. DataJoint will call make , one-by-one, for every key in Image for which FilteredImage has not yet been computed. The make method receives one argument: the dict key containing the primary key value of an element of key source to be worked on. Optional Arguments \u00b6 Behavior of the populate method depends on the number of output arguments requested in the function call. When no output arguments are requested, errors will halt population. With two output arguments( failedKeys and errors ), populate will catch any encountered errors and return them along with the offending keys. Progress \u00b6 The function parpopulate works identically to populate except that it uses a job reservation mechanism to allow multiple processes to populate the same table in parallel without collision. When running parpopulate for the first time, DataJoint will create a job reservation table and its class <package>.Jobs with the following declaration: { % # the job reservation table table_name : varchar ( 255 ) # className of the table key_hash : char ( 32 ) # key hash --- status : enum ( 'reserved' , 'error' , 'ignore' ) # if tuple is missing , the job is available key = null : blob # structure containing the key error_message = \"\" : varchar ( 1023 ) # error message returned if failed error_stack = null : blob # error stack if failed host = \"\" : varchar ( 255 ) # system hostname pid = 0 : int unsigned # system process id timestamp = CURRENT_TIMESTAMP : timestamp # automatic timestamp %} A job is considered to be available when <package>.Jobs contains no matching entry. For each make call, parpopulate sets the job status to reserved . When the job is completed, the record is removed. If the job results in error, the job record is left in place with the status set to error and the error message and error stacks saved. Consequently, jobs that ended in error during the last execution will not be attempted again until you delete the corresponding entities from <package>.Jobs . The primary key of the jobs table comprises the name of the class and a 32-character hash of the job's primary key. However, the key is saved in a separate field for error debugging purposes.", "title": "Make Method"}, {"location": "reproduce/make-method/#make-method", "text": "Consider the following table definition from the article on table tiers : %{ Filtered image -> test . Image --- filtered_image : longblob %} classdef FilteredImage < dj . Computed methods ( Access = protected ) function makeTuples ( self, key ) img = fetch1 ( test . Image & key , 'image' ); key . filtered_image = my_filter ( img ); self . insert ( key ) end end end The FilteredImage table can be populated as populate ( test . FilteredImage ) Note that it is not necessary to specify which data needs to be computed. DataJoint will call make , one-by-one, for every key in Image for which FilteredImage has not yet been computed. The make method receives one argument: the dict key containing the primary key value of an element of key source to be worked on.", "title": "Make Method"}, {"location": "reproduce/make-method/#optional-arguments", "text": "Behavior of the populate method depends on the number of output arguments requested in the function call. When no output arguments are requested, errors will halt population. With two output arguments( failedKeys and errors ), populate will catch any encountered errors and return them along with the offending keys.", "title": "Optional Arguments"}, {"location": "reproduce/make-method/#progress", "text": "The function parpopulate works identically to populate except that it uses a job reservation mechanism to allow multiple processes to populate the same table in parallel without collision. When running parpopulate for the first time, DataJoint will create a job reservation table and its class <package>.Jobs with the following declaration: { % # the job reservation table table_name : varchar ( 255 ) # className of the table key_hash : char ( 32 ) # key hash --- status : enum ( 'reserved' , 'error' , 'ignore' ) # if tuple is missing , the job is available key = null : blob # structure containing the key error_message = \"\" : varchar ( 1023 ) # error message returned if failed error_stack = null : blob # error stack if failed host = \"\" : varchar ( 255 ) # system hostname pid = 0 : int unsigned # system process id timestamp = CURRENT_TIMESTAMP : timestamp # automatic timestamp %} A job is considered to be available when <package>.Jobs contains no matching entry. For each make call, parpopulate sets the job status to reserved . When the job is completed, the record is removed. If the job results in error, the job record is left in place with the status set to error and the error message and error stacks saved. Consequently, jobs that ended in error during the last execution will not be attempted again until you delete the corresponding entities from <package>.Jobs . The primary key of the jobs table comprises the name of the class and a 32-character hash of the job's primary key. However, the key is saved in a separate field for error debugging purposes.", "title": "Progress"}, {"location": "reproduce/table-tiers/", "text": "Table Tiers \u00b6 To define a DataJoint table in Matlab: Define the table via multi-line comment. Define a class inheriting from the appropriate DataJoint class: dj.Lookup , dj.Manual , dj.Imported or dj.Computed . Manual Tables \u00b6 The following code defines two manual tables, Animal and Session : File +experiment/Animal.m %{ # information about animal animal_id : int # animal id assigned by the lab --- -> experiment.Species date_of_birth=null : date # YYYY-MM-DD optional sex='' : enum('M', 'F', '') # leave empty if unspecified %} classdef Animal < dj . Manual end File +experiment/Session.m %{ # Experiment Session -> experiment.Animal session : smallint # session number for the animal --- session_date : date # YYYY-MM-DD session_start_time : float # seconds relative to session_datetime session_end_time : float # seconds relative to session_datetime -> [nullable] experiment.User %} classdef Session < dj . Manual end Note that the notation to permit null entries differs for attributes versus foreign key references. Lookup Tables \u00b6 Lookup tables are commonly populated from their contents property. The table below is declared as a lookup table with its contents property provided to generate entities. File +lab/User.m %{ # users in the lab username : varchar(20) # user in the lab --- first_name : varchar(20) # user first name last_name : varchar(20) # user last name %} classdef User < dj . Lookup properties contents = { 'cajal' 'Santiago' 'Cajal' 'hubel' 'David' 'Hubel' 'wiesel' 'Torsten' 'Wiesel' } end end Imported and Computed Tables \u00b6 Imported and Computed tables provide make methods to determine how they are populated, either from files or other tables. Imagine that there is a table test.Image that contains 2D grayscale images in its image attribute. We can define the Computed table, test.FilteredImage that filters the image in some way and saves the result in its filtered_image attribute. %{ Filtered image -> test . Image --- filtered_image : longblob %} classdef FilteredImage < dj . Computed methods ( Access = protected ) function makeTuples ( self, key ) img = fetch1 ( test . Image & key , 'image' ); key . filtered_image = my_filter ( img ); self . insert ( key ) end end end makeTuples vs. make Currently matlab uses makeTuples rather than make . This will be fixed in an upcoming release. You can monitor the discussion here Part Tables \u00b6 The following code defines a Imported table with an associated part table. In MATLAB, the master and part tables are declared in a separate classdef file. The name of the part table must begin with the name of the master table. The part table must declare the property master containing an object of the master. +image/Scan.m %{ # Two-photon imaging scan -> Session scan : smallint # scan number within the session --- -> Lens laser_wavelength : decimal(5,1) # um laser_power : decimal(4,1) # mW %} classdef Scan < dj . Computed methods ( Access = protected ) function make ( self, key ) self . insert ( key ) make ( image . ScanField , key ) end end end +image/ScanField.m %{ # Region of interest resulting from segmentation -> image.Scan mask : smallint --- ROI : longblob # Region of interest %} classdef ScanField < dj . Part properties ( SetAccess = protected ) master = image . Scan end methods function make ( self, key ) ... self . insert ( entity ) end end end", "title": "Table Tiers"}, {"location": "reproduce/table-tiers/#table-tiers", "text": "To define a DataJoint table in Matlab: Define the table via multi-line comment. Define a class inheriting from the appropriate DataJoint class: dj.Lookup , dj.Manual , dj.Imported or dj.Computed .", "title": "Table Tiers"}, {"location": "reproduce/table-tiers/#manual-tables", "text": "The following code defines two manual tables, Animal and Session : File +experiment/Animal.m %{ # information about animal animal_id : int # animal id assigned by the lab --- -> experiment.Species date_of_birth=null : date # YYYY-MM-DD optional sex='' : enum('M', 'F', '') # leave empty if unspecified %} classdef Animal < dj . Manual end File +experiment/Session.m %{ # Experiment Session -> experiment.Animal session : smallint # session number for the animal --- session_date : date # YYYY-MM-DD session_start_time : float # seconds relative to session_datetime session_end_time : float # seconds relative to session_datetime -> [nullable] experiment.User %} classdef Session < dj . Manual end Note that the notation to permit null entries differs for attributes versus foreign key references.", "title": "Manual Tables"}, {"location": "reproduce/table-tiers/#lookup-tables", "text": "Lookup tables are commonly populated from their contents property. The table below is declared as a lookup table with its contents property provided to generate entities. File +lab/User.m %{ # users in the lab username : varchar(20) # user in the lab --- first_name : varchar(20) # user first name last_name : varchar(20) # user last name %} classdef User < dj . Lookup properties contents = { 'cajal' 'Santiago' 'Cajal' 'hubel' 'David' 'Hubel' 'wiesel' 'Torsten' 'Wiesel' } end end", "title": "Lookup Tables"}, {"location": "reproduce/table-tiers/#imported-and-computed-tables", "text": "Imported and Computed tables provide make methods to determine how they are populated, either from files or other tables. Imagine that there is a table test.Image that contains 2D grayscale images in its image attribute. We can define the Computed table, test.FilteredImage that filters the image in some way and saves the result in its filtered_image attribute. %{ Filtered image -> test . Image --- filtered_image : longblob %} classdef FilteredImage < dj . Computed methods ( Access = protected ) function makeTuples ( self, key ) img = fetch1 ( test . Image & key , 'image' ); key . filtered_image = my_filter ( img ); self . insert ( key ) end end end makeTuples vs. make Currently matlab uses makeTuples rather than make . This will be fixed in an upcoming release. You can monitor the discussion here", "title": "Imported and Computed Tables"}, {"location": "reproduce/table-tiers/#part-tables", "text": "The following code defines a Imported table with an associated part table. In MATLAB, the master and part tables are declared in a separate classdef file. The name of the part table must begin with the name of the master table. The part table must declare the property master containing an object of the master. +image/Scan.m %{ # Two-photon imaging scan -> Session scan : smallint # scan number within the session --- -> Lens laser_wavelength : decimal(5,1) # um laser_power : decimal(4,1) # mW %} classdef Scan < dj . Computed methods ( Access = protected ) function make ( self, key ) self . insert ( key ) make ( image . ScanField , key ) end end end +image/ScanField.m %{ # Region of interest resulting from segmentation -> image.Scan mask : smallint --- ROI : longblob # Region of interest %} classdef ScanField < dj . Part properties ( SetAccess = protected ) master = image . Scan end methods function make ( self, key ) ... self . insert ( entity ) end end end", "title": "Part Tables"}]}